
# What is an interrupt?
An interrupt is an event that alters the normal execution flow of a program and <br>
can be generated by hardware devices or even by the CPU itself. When an interrupt <br>
occurs the current flow of execution is suspended and interrupt handler runs. After <br>
the interrupt handler runs the previous execution flow is resumed.

## Types of interrupts
1) `synchronous` - generated by executing an instruction.
2) `Asynchronous` - generated by an external event.
3) `Maskable` - 
4) `Non-maskable` -

> Synchronous interrupts, usually named `exceptions`, handle conditions detected by the processor itself <br>in the course of executing an instruction.<br> Divide by zero or a system call are examples of exceptions.

> Asynchronous interrupts, usually named `interrupts`, are external events generated by I/O devices.<br>For example a network card generates an interrupts to signal that a packet has arrived.

> Most interrupts are maskable, which means we can temporarily postpone running the interrupt handler.<br> However, there are a few critical interrupts that can not be disabled/postponed.

## Exception
There are two sources for exceptions:
1) processor detected - `[fault, trap, abort]`
2) programmed - `[int n]`

> Processor detected exceptions are raised when an abnormal condition is detected while executing an instruction.

> A fault is a type of exception that is reported before the execution of the instruction and can be usually corrected. <br>The saved EIP is the address of the instruction that caused the fault, so after the fault is corrected <br>the program can re-execute the faulty instruction. (e.g page fault).

> A trap is a type of exception that is reported after the execution of the instruction in which the exception was detected. <br>The saved EIP is the address of the instruction after the instruction that caused the trap. (e.g debug trap).<br>
* Division by Zero
* Illegal Opcode
* Breakpoints

| Term      | Think of it as                     | Behavior                               |
| --------- | ---------------------------------- | -------------------------------------- |
| **Fault** | *“Oops, fix and retry.”*           | Instruction failed midway              |
| **Trap**  | *“All done, now call supervisor.”* | Instruction completed, exception after |
| **Abort** | *“Too bad, can’t continue.”*       | Severe fault (non-recoverable)         |

## Trap
**Defination:** A fault in ARM occurs during instruction execution, before the instruction retires (completes).<br> The CPU aborts the instruction and transfers control to an exception handler.<br> If recoverable, the instruction can be retried after the handler returns.

| Type                           | Exception               | Typical Reason                                                |
| ------------------------------ | ----------------------- | ------------------------------------------------------------- |
| **Instruction Abort**          | `Synchronous exception` | Fetching an instruction from unmapped or inaccessible memory. |
| **Data Abort**                 | `Synchronous exception` | Accessing invalid or unmapped memory (similar to page fault). |
| **Alignment Fault**            | `Synchronous exception` | Misaligned access on architectures that require alignment.    |
| **Synchronous External Abort** | `SError`                | Memory system error detected during access.                   |

**Analogy :** `The instruction failed — handle the issue, then try it again.`


## Trap
**Defination**: A trap in ARM occurs after an instruction successfully completes, and it’s usually intentional — used for system calls, debugging, or EL transitions.

| Type                          | Exception               | Trigger                                                                                |
| ----------------------------- | ----------------------- | -------------------------------------------------------------------------------------- |
| **SVC (Supervisor Call)**     | `Synchronous exception` | Executed when EL0 (user) calls `svc #imm`, to request kernel service.                  |
| **HVC (Hypervisor Call)**     | `Synchronous exception` | Used by a guest OS to call the hypervisor.                                             |
| **SMC (Secure Monitor Call)** | `Synchronous exception` | Used for communication between Normal and Secure world (e.g., EL3 firmware like TF-A). |
| **BRK (Breakpoint)**          | `Synchronous exception` | Used for debugging traps.                                                              |

**Analogy :** `I finished my work — now call my supervisor before moving on.`

# Process to handle interrupt
When system get any interrupt. it envoke specified `interrupt handler`. `interrupt handler` is register at the time of `compile or boot`.<br>
Once control reach to ISR. ISR do following things.
1) Disable IRQ line which cause intrrupt.
2) `Do your work quickly.`
3) Enable IRQ line which casue interrupt.

Problems start at steps 2. Probems are as following.
1) What if software take longer time to complete the task.
2) what if high priority interrupt came.
3) what if ISR get sleep.
4) what if ISR deadlock.

To address these issue multiple solutions came into picture. These solutions are depends on the operating system and harware capabilites.

**In Linux kernel,** `Interrupt context` can not be preempty aka context switch, sleep and schedule [1].

Hence, It is developer responsibility to make ISR fast, non sleepable and lock free.

[1] [Kernel Doc](https://linux-kernel-labs.github.io/refs/heads/master/lectures/interrupts.html)


# Top Half vs Bottom Half
Top half of an ISR must follow 3 conditions.
1) If the work is time sensitive
2) If the work is related to the hardware
3) If the work ensure that another interrupt does not interupt it.

**Defination:** Portion of an ISR which handles time sensitive, related to hadware and un-interrupted work known as Top Half.

**For Everything else, consider performing the work in the bottom half.**

# Original Bottom half

The BH interface was simple. it provided a statically created list of 32 bottom halves for<br> 
the entire system.The top half could mark whether the bottom half would run by setting<br> 
a bit in a 32-bit integer. Each BH was globally synchronized. No two could run at the<br> 
same time, even on different processors.This was easy to use, yet inflexible; a simple<br> 
approach, yet a bottleneck in SMP.

All the kernel’s mechanisms for deferring work are “bottom halves.”<br>
"Later" simply means "not now." Bottom halves defer work to a future time <br>
when the system is less busy and interrupts are enabled—not to a specific moment,<br>
just anytime after the interrupt handler finishes.

So,
* ✅ Easy to use.
* ❌ Limited to 32.
* ❌ No parallel work (even with multiple CPUs).

That’s why Linux later introduced better methods like **tasklets** and **workqueues**, <br>
to allow more flexible and parallel processing.<br>
But  It also was not lightweight enough for performance critical subsystems, such as networking.<br>

Hence There are 4 bottom half mechanisms available in Linux:
1) softirq - `Executed in an atomic context.`
2) Tasklets - `Executed in an atomic context.`
3) WorkQueues - `Executed in a process context.`
4) Threaded IRQs

**NOTE:** Old BH and task queue interfaces are also available but as memories. `Kernel Timers` is also a mechanism for deferring work.

# Workqueue in Linux Kernel
Work queues are a different form of deferring work. Work queues defer work into a kernel thread; this bottom half always runs in the `process context.`

* Code deferred to a work queue has all the usual benefits of process context.
* Most importantly, work queues are schedulable and can therefore sleep.

There are two ways to implement Workqueue in the Linux kernel.

1) Using global workqueue (Static / Dynamic)
2) Creating Own workqueue

## Using Global Workqueue (Global Worker Thread)
In this method no need to create any workqueue or worker thread. So in this method,<br>we only need to initialize work. We can initialize the work using two methods.
* [Static method](https://embetronicx.com/tutorials/linux/device-drivers/workqueue-in-linux-kernel/)
* [Dynamic method](https://embetronicx.com/tutorials/linux/device-drivers/workqueue-in-linux-dynamic-creation/)

**NOTE:** Normally, it is easy to decide between using workqueue and softirq/tasklet:

* If the deferred work needs to sleep, then workqueue is used.
* If the deferred work needs not sleep, then softirq or tasklet are used.


# Softirq vs Tasklets
## softirq
1) Number of softirqs is statically determined at compile time.<br>
As of now in kernel 6.15 `NR_SOFTIRQS = 11` entries in struct softirq_action softirq_vec[NR_SOFTIRQS]<br>

   ![1753247343375](image/Linux_interrupt/1753247343375.png)

2) A registered softirq must be marked before it will execute.This is called raising the softirq.
    * Usually, an interrupt handler marks its softirq for execution before returning.Then, at a
      suitable time, the softirq runs.

3)  Pending softirqs are checked for and executed in the following places:
    * In the return from hardware interrupt code path.
    * In the ksoftirqd kernel thread.
    * In any code that explicitly checks for and executes pending softirqs, such as the networking subsystem.
      
    **NOTE:** Regardless of the method of invocation, softirq execution occurs in __do_softirq(),
      which is invoked by do_softirq()

4) Softirqs are reserved for the `most timing-critical and important bottom-half processing on the system.`<br>
Currently, only two subsystems—`networking` and `block devices`—directly use softirqs.Additionally,<br>
kernel timers and tasklets are built on top of softirqs.

5) By convention, HI_SOFTIRQ is always the first and RCU_SOFTIRQ is always the last entry.

## tasklets
1) Tasklets are implemented on top of softirqs, they are softirq.
2) Tasklets are represented by two softirqs: `HI_SOFTIRQ and TASKLET_SOFTIRQ`.<br>
The only difference in these types is that the HI_SOFTIRQ-based tasklets run <br>
prior to the TASKLET_SOFTIRQ based tasklets.


### Softirq and Tasklets difference

| Properity   | Softirq | tasklets |
|-------------|----------|----------|
| Allocation  | Softirqs are statically allocated at compile-time. Unlike tasklets,<br> you cannot dynamically register and destroy softirqs. | Tasklets can be statically allocated using DECLARE_TASKLET(name, func, data) <br>or can also be allocated dynamically and initialized at runtime using tasklet_init(name, func, data) |
| Concurrency | Softirqs can run concurrently on several CPUs, even if they are of the <br>same type because softirqs are reentrant functions and must explicitly <br>protect their data structures with spinlocks. | Tasklets are non-reentrant and tasklets of the same type are always serialized: <br>in other words, the same type of tasklet cannot be executed by two CPUs at the same time. <br>However, tasklets of different types can be executed concurrently on several CPUs. |
| Processing  | Softirqs are activated by means of the raise_softirq(). The pending softirqs are processed by do_softirq() <br>and ksoftirqd kernel thread after being enabled by local_bh_enable() or by spin_unlock_bh() | Tasklets are a bottom-half mechanism built on top of softirqs i.e. <br>tasklets are represented by two softirqs: HI_SOFTIRQ and TASKLET_SOFTIRQ. <br>Tasklets are actually run from a softirq. The only real difference in these types is that the HI_SOFTIRQ based tasklets <br>run prior to the TASKLET_SOFTIRQ tasklets. So, tasklet_schedule() basically calls raise_softirq(TASKLET_SOFTIRQ) |

# [Softirq Example](https://embetronicx.com/tutorials/linux/device-drivers/softirq-in-linux-kernel/)

## Patch needed for necessary changes in Linux source code.

```diff
pi@raspberrypi:~/Desktop/workspace/linux_cus_kernel/linux $ git diff
diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index ee8299eb1..0553cb127 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -537,6 +537,7 @@ enum
        SCHED_SOFTIRQ,
        HRTIMER_SOFTIRQ,
        RCU_SOFTIRQ,    /* Preferable RCU should always be the last softirq */
+        EMBETRONICX_SOFT_IRQ,    /* Manually added for educational purpose */
 
        NR_SOFTIRQS
 };
diff --git a/kernel/softirq.c b/kernel/softirq.c
index 09229ad82..887dd60d3 100644
--- a/kernel/softirq.c
+++ b/kernel/softirq.c
@@ -469,6 +469,7 @@ inline void raise_softirq_irqoff(unsigned int nr)
        if (!in_interrupt())
                wakeup_softirqd();
 }
+EXPORT_SYMBOL(raise_softirq_irqoff);
 
 void raise_softirq(unsigned int nr)
 {
@@ -478,6 +479,7 @@ void raise_softirq(unsigned int nr)
        raise_softirq_irqoff(nr);
        local_irq_restore(flags);
 }
+EXPORT_SYMBOL(raise_softirq);
 
 void __raise_softirq_irqoff(unsigned int nr)
 {
@@ -490,6 +492,7 @@ void open_softirq(int nr, void (*action)(struct softirq_action *))
 {
        softirq_vec[nr].action = action;
 }
+EXPORT_SYMBOL(open_softirq);
 
 /*
  * Tasklets
```
-------------------------------------------------------------------------------

## Actual driver code which demostrated softirq functionality.


```c
/***************************************************************************//**
*  \file       driver.c
*
*  \details    Simple GPIO driver explanation (Softirq)
* 
*              We made the below changes in the linux kernel to support the 
*              softirq.
*           
*              1. Added EMBETRONICX_SOFT_IRQ in interrupt.h
*              2. Exported the APIs(raise_softirq, raise_softirq_irqoff, open_softirq)
*              3. Compiled the modified kernel and used that
*
*  \author     EmbeTronicX
*
*  \Tested with Linux raspberrypi 5.10.27-v7l-embetronicx-custom+
*
*******************************************************************************/
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kdev_t.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/delay.h>
#include <linux/uaccess.h>  //copy_to/from_user()
#include <linux/gpio.h>     //GPIO
#include <linux/interrupt.h>
#include <linux/err.h>
/* Since debounce is not supported in Raspberry pi, I have addded this to disable 
** the false detection (multiple IRQ trigger for one interrupt).
** Many other hardware supports GPIO debounce, I don't want care about this even 
** if this has any overhead. Our intention is to explain the GPIO interrupt.
** If you want to disable this extra coding, you can comment the below macro.
** This has been taken from : https://raspberrypi.stackexchange.com/questions/8544/gpio-interrupt-debounce
**
** If you want to use Hardaware Debounce, then comment this EN_DEBOUNCE.
**
*/
#define EN_DEBOUNCE

#ifdef EN_DEBOUNCE
#include <linux/jiffies.h>

extern unsigned long volatile jiffies;
unsigned long old_jiffie = 0;
#endif

//LED is connected to this GPIO
#define GPIO_21_OUT (21)

//LED is connected to this GPIO
#define GPIO_25_IN  (25)

//GPIO_25_IN value toggle
unsigned int led_toggle = 0; 

//This used for storing the IRQ number for the GPIO
unsigned int GPIO_irqNumber;

//Interrupt handler for GPIO 25. This will be called whenever there is a raising edge detected. 
static irqreturn_t gpio_irq_handler(int irq,void *dev_id) 
{
  
#ifdef EN_DEBOUNCE
   unsigned long diff = jiffies - old_jiffie;
   if (diff < 20)
   {
     return IRQ_HANDLED;
   }
  
  old_jiffie = jiffies;
#endif  
  
  /* Raise the softirq */
  raise_softirq( EMBETRONICX_SOFT_IRQ );
    
  return IRQ_HANDLED;
}

/*
** This fuction is the softirq handler
*/
static void gpio_interrupt_softirq_handler(struct softirq_action *action)
{
  led_toggle = (0x01 ^ led_toggle);                             // toggle the old value
  gpio_set_value(GPIO_21_OUT, led_toggle);                      // toggle the GPIO_21_OUT
  pr_info("Interrupt Occurred : GPIO_21_OUT : %d ",gpio_get_value(GPIO_21_OUT));
}


dev_t dev = 0;
static struct class *dev_class;
static struct cdev etx_cdev;
 
static int __init etx_driver_init(void);
static void __exit etx_driver_exit(void);
 
 
/*************** Driver functions **********************/
static int etx_open(struct inode *inode, struct file *file);
static int etx_release(struct inode *inode, struct file *file);
static ssize_t etx_read(struct file *filp, 
                char __user *buf, size_t len,loff_t * off);
static ssize_t etx_write(struct file *filp, 
                const char *buf, size_t len, loff_t * off);
/******************************************************/

//File operation structure 
static struct file_operations fops =
{
  .owner          = THIS_MODULE,
  .read           = etx_read,
  .write          = etx_write,
  .open           = etx_open,
  .release        = etx_release,
};

/*
** This function will be called when we open the Device file
*/
static int etx_open(struct inode *inode, struct file *file)
{
  pr_info("Device File Opened...!!!\n");
  return 0;
}

/*
** This function will be called when we close the Device file
*/
static int etx_release(struct inode *inode, struct file *file)
{
  pr_info("Device File Closed...!!!\n");
  return 0;
}

/*
** This function will be called when we read the Device file
*/
static ssize_t etx_read(struct file *filp, 
                char __user *buf, size_t len, loff_t *off)
{
  uint8_t gpio_state = 0;
  
  //reading GPIO value
  gpio_state = gpio_get_value(GPIO_21_OUT);
  
  //write to user
  len = 1;
  if( copy_to_user(buf, &gpio_state, len) > 0) {
    pr_err("ERROR: Not all the bytes have been copied to user\n");
  }
  
  pr_info("Read function : GPIO_21 = %d \n", gpio_state);
  
  return 0;
}

/*
** This function will be called when we write the Device file
*/
static ssize_t etx_write(struct file *filp, 
                const char __user *buf, size_t len, loff_t *off)
{
  uint8_t rec_buf[10] = {0};
  
  if( copy_from_user( rec_buf, buf, len ) > 0) {
    pr_err("ERROR: Not all the bytes have been copied from user\n");
  }
  
  pr_info("Write Function : GPIO_21 Set = %c\n", rec_buf[0]);
  
  if (rec_buf[0]=='1') {
    //set the GPIO value to HIGH
    gpio_set_value(GPIO_21_OUT, 1);
  } else if (rec_buf[0]=='0') {
    //set the GPIO value to LOW
    gpio_set_value(GPIO_21_OUT, 0);
  } else {
    pr_err("Unknown command : Please provide either 1 or 0 \n");
  }
  
  return len;
}

/*
** Module Init function
*/
static int __init etx_driver_init(void)
{
  /*Allocating Major number*/
  if((alloc_chrdev_region(&dev, 0, 1, "etx_Dev")) <0){
    pr_err("Cannot allocate major number\n");
    goto r_unreg;
  }
  pr_info("Major = %d Minor = %d \n",MAJOR(dev), MINOR(dev));

  /*Creating cdev structure*/
  cdev_init(&etx_cdev,&fops);

  /*Adding character device to the system*/
  if((cdev_add(&etx_cdev,dev,1)) < 0){
    pr_err("Cannot add the device to the system\n");
    goto r_del;
  }

  /*Creating struct class*/
  if(IS_ERR(dev_class = class_create(THIS_MODULE,"etx_class"))){
    pr_err("Cannot create the struct class\n");
    goto r_class;
  }

  /*Creating device*/
  if(IS_ERR(device_create(dev_class,NULL,dev,NULL,"etx_device"))){
    pr_err( "Cannot create the Device \n");
    goto r_device;
  }
  
  //Output GPIO configuration
  //Checking the GPIO is valid or not
  if(gpio_is_valid(GPIO_21_OUT) == false){
    pr_err("GPIO %d is not valid\n", GPIO_21_OUT);
    goto r_device;
  }
  
  //Requesting the GPIO
  if(gpio_request(GPIO_21_OUT,"GPIO_21_OUT") < 0){
    pr_err("ERROR: GPIO %d request\n", GPIO_21_OUT);
    goto r_gpio_out;
  }
  
  //configure the GPIO as output
  gpio_direction_output(GPIO_21_OUT, 0);
  
  //Input GPIO configuratioin
  //Checking the GPIO is valid or not
  if(gpio_is_valid(GPIO_25_IN) == false){
    pr_err("GPIO %d is not valid\n", GPIO_25_IN);
    goto r_gpio_in;
  }
  
  //Requesting the GPIO
  if(gpio_request(GPIO_25_IN,"GPIO_25_IN") < 0){
    pr_err("ERROR: GPIO %d request\n", GPIO_25_IN);
    goto r_gpio_in;
  }
  
  //configure the GPIO as input
  gpio_direction_input(GPIO_25_IN);
  
  /*
  ** I have commented the below few lines, as gpio_set_debounce is not supported 
  ** in the Raspberry pi. So we are using EN_DEBOUNCE to handle this in this driver.
  */ 
#ifndef EN_DEBOUNCE
  //Debounce the button with a delay of 200ms
  if(gpio_set_debounce(GPIO_25_IN, 200) < 0){
    pr_err("ERROR: gpio_set_debounce - %d\n", GPIO_25_IN);
    //goto r_gpio_in;
  }
#endif
  
  //Get the IRQ number for our GPIO
  GPIO_irqNumber = gpio_to_irq(GPIO_25_IN);
  pr_info("GPIO_irqNumber = %d\n", GPIO_irqNumber);
  
  if (request_irq(GPIO_irqNumber,             //IRQ number
                  (void *)gpio_irq_handler,   //IRQ handler
                  IRQF_TRIGGER_RISING,        //Handler will be called in raising edge
                  "etx_device",               //used to identify the device name using this IRQ
                  NULL)) {                    //device id for shared IRQ
    pr_err("my_device: cannot register IRQ ");
    goto r_gpio_in;
  }
  
  /* Assign gpio_interrupt_softirq_handler to the EMBETRONICX_SOFT_IRQ */
  open_softirq( EMBETRONICX_SOFT_IRQ, gpio_interrupt_softirq_handler );
 
  pr_info("Device Driver Insert...Done!!!\n");
  return 0;

r_gpio_in:
  gpio_free(GPIO_25_IN);
r_gpio_out:
  gpio_free(GPIO_21_OUT);
r_device:
  device_destroy(dev_class,dev);
r_class:
  class_destroy(dev_class);
r_del:
  cdev_del(&etx_cdev);
r_unreg:
  unregister_chrdev_region(dev,1);
  
  return -1;
}

/*
** Module exit function
*/ 
static void __exit etx_driver_exit(void)
{
  free_irq(GPIO_irqNumber,NULL);
  gpio_free(GPIO_25_IN);
  gpio_free(GPIO_21_OUT);
  device_destroy(dev_class,dev);
  class_destroy(dev_class);
  cdev_del(&etx_cdev);
  unregister_chrdev_region(dev, 1);
  pr_info("Device Driver Remove...Done!!\n");
}
 
module_init(etx_driver_init);
module_exit(etx_driver_exit);
 
MODULE_LICENSE("GPL");
MODULE_AUTHOR("EmbeTronicX <embetronicx@gmail.com>");
MODULE_DESCRIPTION("A simple device driver - SoftIRQ (GPIO Interrupt) ");
MODULE_VERSION("1.42");
```

## Output

```c
[  +0.000352] GPIO_irqNumber = 67
[  +0.000044] Device Driver Insert...Done!!!
[Apr11 17:07] Interrupt Occurred : GPIO_21_OUT : 1
```



